---
title: "Kit-comparision"
author: "Ranjit kumar"
date: "December 28, 2016"
output: html_document
---
  
<br/>

### Background
Compare two RNA-seq libraries of the same UHRR + 1% synthetic ERCC control input (10 ng),  prepared with kits from different vendors. I recommend Salmon for transcript abundance estimation.
Potentially interesting questions:
How sensitive are these two libraries prep methods?
Are high abundance transcripts missing from one or the other library?
What questions arise from your observations?
What other experiments would you design to answer questions?

Figures that speak to these questions would be helpful(e.g. correlations, TPM vs. # of transcripts with at least that TPM (cumulative histogram)).

The cluster has several files which inldues 4 fastq files (paried-end for both kits), the reference file and its index (for salmon).
```
langhorst@ip-192-168-0-253:~/kit_comparison$ ls -l
total 20683076
-rw-rw-r-- 1 langhorst langhorst 4383832100 Nov 12 11:58 10ng_kit1.1.fastq
-rw-rw-r-- 1 langhorst langhorst 4383832100 Nov 12 11:58 10ng_kit1.2.fastq
-rw-rw-r-- 1 langhorst langhorst 4383839514 Nov 12 11:57 10ng_kit2.1.fastq
-rw-rw-r-- 1 langhorst langhorst 4383839514 Nov 12 11:58 10ng_kit2.2.fastq
-rw-rw-r-- 1 langhorst langhorst  298595430 Nov 12 11:49 gencode_v25+ercc.fasta
drwxrwxr-x 2 langhorst langhorst        156 Nov 12 13:58 gencode_v25+ercc.salmon_index
-rw-r--r-- 1 langhorst langhorst 3345517109 Nov 12 12:44 kit_comparison.tgz
drwxrwxr-x 9 langhorst langhorst        128 Dec 28 20:08 Ranjit_analysis
```

### Software installation and system setting (temporary)
Installed FASTQC, Parallel and a software QWRAP which has some utilities to compare FASTQC output. I created a folder Ranjit_analysis for storing all analysis files.
```
mkdir Ranjit_analysis
git clone https://github.com/QWRAP/QWRAPv3.git
export PATH="/home/langhorst/kit_comparison/Ranjit_analysis/QWRAPv3:$PATH"
#FASTQC installation
conda install fastqc
#Parallel installation for multithreading
conda install parallel
# personal system config changes (temporary)
alias lsa='ls -lah --color'
alias wcl='wc -l'
# check system config: seems it had 4 cpu and 16gb RAM
less /proc/meminfo
less /proc/cpuinfo
nproc --all
```

### Check QC
Its good idea to check reads quality before proceeding further, so running all fastq files with FASTQC.
```
FASTQ='/home/langhorst/kit_comparison/'
THREAD=4
parallel -j $THREAD --progress --verbose --joblog qc.log 'fastqc --nogroup {} -o FASTQC' ::: ${FASTQ}/*.fastq
```
Overall the QC looks good so skipping data filtering for this exercise. However few observations can be further explored
* The last base (76th) usually show drop in quality, so it can be trimmed if it increases alignment percentage.
* The first few bases (around 10) shows GC content bais, they can also be trimmed to check if it increases alignemnt percentage.
* Very low percentage of ribosomal RNA detected. Shouldn't be a problem though.

### Running salmon for quantification
```
INDEX="/home/langhorst/kit_comparison/gencode_v25+ercc.salmon_index/"
mkdir SALMON
# run salmon program in series
salmon quant -i $INDEX -l A -1 $FASTQ/10ng_kit1.1.fastq -2 $FASTQ/10ng_kit1.2.fastq -p $THREAD -o SALMON/kit1.out
salmon quant -i $INDEX -l A -1 $FASTQ/10ng_kit2.1.fastq -2 $FASTQ/10ng_kit2.2.fastq -p $THREAD -o SALMON/kit2.out
```
**Note: In absence of knowledge of library type, I put the libtype in automatic discovery mode. It predicts library to be ISR. If that is not how the library protocol is, I would investigate further and probably providing the correct library type while running salmon.**

The alignment percentage reported by salmon is 67% for kit1 and 77% for kit2. This suggest further data filtering parameters can be explored to check if that increases alignment percentage. It also suggest kit2 may be better as it is producing more reads whcih are being aligned.

Salmon produces quant.sf file which contains transcript quantification. 
```
langhorst@ip-192-168-0-253:~/kit_comparison/Ranjit_analysis$ ls SALMON/*/
SALMON/kit1.out/:
aux_info  cmd_info.json  lib_format_counts.json  libParams  logs  quant.sf

SALMON/kit2.out/:
aux_info  cmd_info.json  lib_format_counts.json  libParams  logs  quant.sf
```

### Results
I created folder kit-compare and copied both quant file in it and explored them further using R.
```
mkdir kit_compare
cp SALMON/kit1.out/quant.sf kit-compare/kit1.quant.sf
cp SALMON/kit2.out/quant.sf kit-compare/kit2.quant.sf
```


Get the quant files generated by salmon for two kits in directory and set the path
```{r}
setwd("~/brad/kit-compare")
dir()
```

Read both files and merge the information
```{r}
# Read quant files as table
kit1<-read.table(file="kit1.quant.sf",header=T,sep="\t",comment.char = "",stringsAsFactors = FALSE)
kit2<-read.table(file="kit2.quant.sf",header=T,sep="\t",comment.char = "",stringsAsFactors = FALSE)

# Merge information from both kits
both_kit <- merge(kit1, kit2, by.x="Name", by.y="Name")

# Change column names
colnames(both_kit) <- c("Name","Length.kit1","EffectiveLength.kit1","TPM.kit1","NumReads.kit1","Length.kit2","EffectiveLength.kit2","TPM.kit2","NumReads.kit2")

#Mark control ERCC fragment in new column "type""
both_kit$type = ifelse(grepl("ENST",both_kit$Name),"ENST","ERCC")
```

library(reshape2)
library(ggplot2)

Ercc_control<-read.table(file="cms_095046.txt",header=T,sep="\t",comment.char = "",stringsAsFactors = FALSE)
Ercc_control <- Ercc_control[order(Ercc_control$ERCC.ID),]
Ercc_tpm <- both_kit[both_kit$type == "ERCC",c("TPM.kit1","TPM.kit2","Name")]
Ercc_tpm$TPM.kit1 <- round(Ercc_tpm$TPM.kit1,3)
Ercc_tpm$TPM.kit2 <- round(Ercc_tpm$TPM.kit2,3)

#Ercc <- cbind(Ercc_tpm,Ercc_control$concentration.in.Mix.1..attomoles.ul.)
#colnames(Ercc)[4] <- "Mix1"
#Ercc$Mix1 <- round(Ercc$Mix1,3)
#Ercc_melt <- melt(Ercc_tpm,value.name="TPM")

# Sensitivity
#Cutoff <- 0
Cutoff <- 1
Ercc_tpm1 = Ercc_tpm

kit1 <- Ercc_tpm1[Ercc_tpm1$TPM.kit1 > Cutoff,c("Name")]
kit2 <- Ercc_tpm1[Ercc_tpm1$TPM.kit2 > Cutoff,c("Name")]

library(VennDiagram)
venn.diagram(x=list("Kit1"=kit1,"Kit2"=kit2),filename="Venn_cutoff0.png",imagetype="png",fill = c("skyblue", "pink1"))
venn.diagram(x=list("Kit1"=kit1,"Kit2"=kit2),filename="Venn_cutoff1.png",imagetype="png",fill = c("skyblue", "pink1"))

both_tpm_enst <- both_kit[both_kit$type == "ENST",c("TPM.kit1","TPM.kit2")]
both_tpm_enst$label = 1:nrow(both_tpm_enst)

kit1 <- both_tpm_enst[both_tpm_enst$TPM.kit1 > Cutoff,c("label")]
kit2 <- both_tpm_enst[both_tpm_enst$TPM.kit2 > Cutoff,c("label")]

venn.diagram(x=list("Kit1"=kit1,"Kit2"=kit2),filename="enst_venn_cutoff0.png",imagetype="png",fill = c("skyblue", "pink1"))
venn.diagram(x=list("Kit1"=kit1,"Kit2"=kit2),filename="enst_venn_cutoff1.png",imagetype="png",fill = c("skyblue", "pink1"))

########

tpm_enst <- melt(both_tpm_enst[,c("TPM.kit1","TPM.kit2")],value.name="TPM")
 #http://stackoverflow.com/questions/18379933/plotting-cumulative-counts-in-ggplot2
 #http://dantalus.github.io/2015/08/16/step-plots/
 
  ggplot(tpm_enst,aes(x=log(TPM),color=variable)) +
  stat_bin(data=subset(tpm_enst,variable=="TPM.kit1"),aes(y=cumsum(..count..)),bins=100,geom="step")+
  stat_bin(data=subset(tpm_enst,variable=="TPM.kit2"),aes(y=cumsum(..count..)),bins=100,geom="step")
  
  
  ggplot(tpm_enst,aes(x=log(TPM),fill=variable)) +
  geom_histogram(alpha=.5,bins = 100,position="identity")  +
  scale_x_continuous(limits = c(-5, 5))





#Cutoff <- 0
Cutoff <- 1
Ercc_tpm1 = Ercc_tpm

kit1 <- Ercc_tpm1[Ercc_tpm1$TPM.kit1 > Cutoff,c("Name")]
kit2 <- Ercc_tpm1[Ercc_tpm1$TPM.kit2 > Cutoff,c("Name")]

library(VennDiagram)
venn.diagram(x=list("Kit1"=kit1,"Kit2"=kit2),filename="Venn_cutoff0.png",imagetype="png",fill = c("skyblue", "pink1"))
venn.diagram(x=list("Kit1"=kit1,"Kit2"=kit2),filename="Venn_cutoff1.png",imagetype="png",fill = c("skyblue", "pink1"))




plot(log(Ercc$TPM.kit1),log(Ercc$Mix1 ))
plot(log(Ercc$TPM.kit1),log(Ercc$TPM.kit2 ))
cor(log(Ercc$TPM.kit1),log(Ercc$TPM.kit2 ))

ggplot(data=Ercc_melt, aes(x=log(TPM),fill=variable,colour=variable)) + 
  geom_histogram( alpha=.5,bins = 10) + 
  geom_density(alpha=.5) + 
  #geom_vline(xintercept = log(50),colour="grey20") +
  facet_grid(variable ~ .)

p <- ggplot(Ercc_control, aes(log(TPM.kit1 + 0.1),log(TPM.kit2 + 0.1),color=type))
p + geom_point(size=0.1) + geom_smooth() + geom_abline(intercept = 45, slope = 200)



library(psych)
both_kit_small <- both_kit[,c("EffectiveLength.kit1","TPM.kit1","NumReads.kit1","EffectiveLength.kit2","TPM.kit2","NumReads.kit2")]
pairs.panels(log(both_kit_small + 0.1))


library(reshape2)
library(ggplot2)

both_tpm_ercc <- both_kit[both_kit$type == "ERCC",c("TPM.kit1","TPM.kit2")]
both_tpm_enst <- both_kit[both_kit$type == "ENST",c("TPM.kit1","TPM.kit2")]

both_el_ercc <- both_kit[both_kit$type == "ERCC",c("EffectiveLength.kit1","EffectiveLength.kit2")]
both_el_enst <- both_kit[both_kit$type == "ENST",c("EffectiveLength.kit1","EffectiveLength.kit2")]


both_tpm_ercc_melt <- melt(both_tpm_ercc,value.name="TPM")

p <- ggplot(Ercc_control, aes(log(TPM.kit1 + 0.1),log(TPM.kit2 + 0.1),color=type))
p + geom_point(size=0.1) + geom_smooth() + geom_abline(intercept = 45, slope = 200)

p <- ggplot(both_kit, aes(log(TPM.kit1 + 0.1),log(TPM.kit2 + 0.1),color=type))
p + geom_point(size=0.1) + geom_smooth() + geom_abline(intercept = 45, slope = 200)

p <- ggplot(both_kit, aes(log(TPM.kit1 + 0.1),log(TPM.kit2 + 0.1),color=type))
p  + geom_smooth() + geom_abline(intercept = 0, slope = 1, linetype = "dashed")

p <- ggplot(both_kit, aes(log(EffectiveLength.kit1 + 0.1),log(EffectiveLength.kit2 + 0.1),color=type))
p  + geom_smooth() + geom_abline(intercept = 0, slope = 1, linetype = "dashed")



sessionInfo()





This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
summary(cars)
```

You can also embed plots, for example:

```{r, echo=FALSE}
plot(cars)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
